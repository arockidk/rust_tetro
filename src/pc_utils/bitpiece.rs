
use std::ops::Sub;

use libdivide::Divider;

use crate::{piece::{Direction, PieceColor}, vec2::Vec2};
// bits 1-2: rotation
// bits 3-8: position
// bits 9-12: color
// sob 4 bits wasted
pub struct BitPiece(pub usize, pub usize, pub usize);
// bits 1-2: rotation
// bits 3-8: position
pub struct Pos(pub u8);
// assume big endian
// each i8 represents the offset of the mino with respect to a base position
// u16 describes the bounds on the position of the piece given a rotation
// minY, maxY, minX, maxX
// 2     2     4     4






pub const MINOS_BOUNDS: [[(u64, u16); 4]; 8] = [
    // filler
    [
        (0,0) ; 4
    ],
    // I
    [        
        (0b1000000000000000000000000000000000000000000000000000000000000111, 0b0000_00_11_0001_0111),
        (0b0000000001000000000100000000000000000000000000000000010000000001, 0b0000_10_10_0000_1001),
        (0b1100000000000000000000000000000000000000000000000000000000000011, 0b0000_00_11_0010_1000),
        (0b0000000001000000000000000000000000000000000100000000010000000001, 0b0000_01_01_0000_1001),
    ],
    // L 
    [
        (0b1000000000000000000000000000000000000000000000000000100000000011, 0b0000_00_10_0001_1000),
        (0b0000000001100000000000000000000000000000000000000000010000000001, 0b0000_01_10_0000_1000),
        (0b1000000000100000000000000000000000000000000000000000000000000011, 0b0000_01_11_0001_1000),
        (0b0000000001000000000000000000000000000000000000000000011000000001, 0b0000_01_10_0001_1001),
    ],
    // O
    [
        (0b0000000000000000000000000000000000000000000000000000110000000011, 0b0000_00_10_0000_1000); 4
    ],
    // Z
    [
        (0b0000000000000000000000000000000000000000000000000000011000000011, 0b0000_00_10_0001_1000),
        (0b0000000001000000000000000000000000000000000000000000100000000011, 0b0000_01_10_0000_1000), 
        (0b1000000011000000000000000000000000000000000000000000000000000001, 0b0000_01_11_0001_1000),
        (0b1000000000100000000000000000000000000000000000000000010000000001, 0b0000_01_10_0001_1001),
    ],
    // T
    [
        (0b1000000000000000000000000000000000000000000000000000010000000011, 0b0000_00_10_0001_1000),
        (0b0000000001000000000000000000000000000000000000000000010000000011, 0b0000_01_10_0000_1000),
        (0b1000000001000000000000000000000000000000000000000000000000000011, 0b0000_01_11_0001_1000),
        (0b1000000001000000000000000000000000000000000000000000010000000001, 0b0000_01_10_0001_1001),
    ],
    // J
    [ 
        (0b1000000000000000000000000000000000000000000000000000001000000011, 0b0000_00_10_0001_1000),
        (0b0000000001000000000000000000000000000000000000000000110000000001, 0b0000_01_10_0000_1000),
        (0b1000000010000000000000000000000000000000000000000000000000000011, 0b0000_01_11_0001_1000),
        (0b0000000001100000000000000000000000000000000000000000010000000001, 0b0000_01_10_0001_1001),
    ],
    // S
    [
        (0b1000000000000000000000000000000000000000000000000000110000000001, 0b0000_00_10_0001_1000),
        (0b0000000010000000000000000000000000000000000000000000010000000011, 0b0000_01_10_0000_1000), 
        (0b0000000001100000000000000000000000000000000000000000000000000011, 0b0000_01_11_0001_1000),
        (0b1000000001000000000000000000000000000000000000000000001000000001, 0b0000_01_10_0001_1001),
    ]
];
pub const KICKS: [[i8; 5] ; 4] = [
    [  0; 5],
    [  0,  1,- 9, 20, 21],
    [  0; 5],
    [  0,- 1,-11, 20, 19],
];
pub const I_KICKS: [[i8; 5] ; 4] = [
    [  0,- 1,  2,- 1,  2],
    [- 1,  0,  0, 10,-20],
    [  9, 11,  8,  1,- 2],
    [ 10, 10, 10,-10, 20],
];
impl BitPiece {
    // 6 bits max for position
    pub fn new(position: u8, rotation: Direction, color: PieceColor) -> BitPiece {
        assert!(position < 40);
        // print!("{} {} {} ", position, rotation as u8, color as u8);
        // println!("{:b} {:b} {:b}", color as u16, position as u16, rotation as u16,  );
        BitPiece(position as usize, rotation as usize, color as usize)
    }
    #[inline]
    #[allow(arithmetic_overflow)]
    pub fn bit_repr(&self) -> u64 {
        let pos = self.0;
        let minos = MINOS_BOUNDS[
            self.2
        ][
            self.1
        ]
        .0;
        minos.rotate_left(pos as u32) 
    }
    #[allow(arithmetic_overflow)]
    #[inline]
    pub fn wall_overlap(&self) -> bool {
        let pos = self.0 as u16;
        let bound_data = MINOS_BOUNDS[
            self.2
        ][
            (self.0 & 0b11) as usize
        ]
        .1;
        let x = 26215-(10*(pos * 26215) >> 18);
    
        x <= (bound_data & 0b1111) && x >= (bound_data >> 4 & 0b1111) && pos & 0b11 >= (bound_data >> 10 & 0b11)
    }
    #[allow(arithmetic_overflow)]
    pub fn in_bounds(&self) -> bool {
        let pos = self.0 as u16;
        let bound_data = MINOS_BOUNDS[
            ((self.0 >> 8 & 0b111)-1) as usize
        ][
            (self.0 & 0b11) as usize
        ]
        .1;
        let x = 26215-(10*(pos * 26215) >> 18);
        let y = pos & 0b11;
        x <= (bound_data & 0b1111) && x >= (bound_data >> 4 & 0b1111) && y <= (bound_data >> 8 & 0b11) && y >= (bound_data >> 10 & 0b11) 
    }

}
impl Vec2 {
    pub fn to_u8(&self) -> u8 {
        let (x, y) = (self.0, self.1);
        (y * 10 + x).try_into().unwrap()
    }
}